<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Sikkim — Interactive GeoJSON Map (Dark, Wide Borders) — Real Roads (Full-image preview)</title>
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@300;400;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    :root{
      --sikkim-blue:#07119e;
      --sikkim-yellow:#fff200;
      --sikkim-red:#ff1b00;
      --sikkim-green:#2ea043;
      --muted:#9fb0c8;
      --panel:rgba(3,6,23,0.70);
      --glass:rgba(255,255,255,0.03);
      --text:#e6eef8;
      --border-dark: #000814; /* dark border color */
      --shadow:0 10px 30px rgba(2,6,23,0.6);
    }
    html,body{ height:100%; margin:0; font-family: Nunito, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; color:var(--text); background: linear-gradient(180deg, #03061a 0%, #071227 60%, #081427 100%); }
    .app{ display:grid; grid-template-columns:360px 1fr; gap:18px; padding:18px; height:100vh; box-sizing:border-box; }
    .panel{ background: linear-gradient(180deg, rgba(255,242,0,0.03), rgba(255,255,255,0.01)), linear-gradient(180deg, rgba(0,0,0,0.08), rgba(0,0,0,0.04)); border-radius:14px; padding:18px; backdrop-filter: blur(6px) saturate(1.06); box-shadow: var(--shadow); border: 1px solid rgba(255,255,255,0.04); color:var(--muted); display:flex; flex-direction:column; gap:12px; transform: translateY(18px); opacity:0; animation: slideIn .6s cubic-bezier(.2,.9,.22,1) forwards; }
    @keyframes slideIn{ to{ transform:none; opacity:1; } }
    .logo{ width:54px; height:42px; border-radius:10px; display:flex; align-items:center; justify-content:center; font-weight:800; color: #071227; font-size:16px; background: linear-gradient(90deg, var(--sikkim-blue) 0% 12%, var(--sikkim-yellow) 12% 88%, var(--sikkim-red) 88% 100%); box-shadow: 0 6px 18px rgba(3,8,40,0.6); border: 1px solid rgba(0,0,0,0.25); }
    .subtitle{ font-size:12px; margin:0; color:var(--muted); }
    #map{ width:100%; height:100%; border-radius:12px; overflow:hidden; box-shadow: var(--shadow); }
    .info{ position:absolute; left:28px; top:28px; z-index:1000; background: linear-gradient(180deg, rgba(3,6,23,0.86), rgba(4,7,35,0.80)); padding:12px 14px; border-radius:12px; color:var(--text); border:1px solid rgba(255,255,255,0.03); box-shadow: 0 10px 30px rgba(2,6,23,0.65); transition: left .22s ease, right .22s ease, transform .22s ease; max-width:360px; }
    .legend-item{ display:flex; gap:10px; align-items:center; font-size:13px; color:var(--text); }
    .swatch{ width:16px; height:14px; border-radius:3px; border:1px solid rgba(0,0,0,0.18); box-shadow:0 3px 10px rgba(2,6,23,0.35) inset; }

    .nice-popup .leaflet-popup-content-wrapper{ border-radius:10px; background: linear-gradient(180deg, #06102a, #071227); color:var(--text); padding:12px; border:2px solid rgba(11, 11, 11, 0.06); box-shadow: 0 10px 24px rgba(3,6,23,0.7); }

    /* Remove SVG focus box that appears on click */
    .leaflet-interactive:focus,
    .leaflet-interactive:active,
    .leaflet-interactive:focus-visible { outline:none !important; box-shadow:none !important; }
    .leaflet-container svg .leaflet-interactive { outline:none !important; -webkit-focus-ring-color: transparent; }

    .leaflet-interactive{ transition: transform 320ms cubic-bezier(.2,.9,.22,1), fill-opacity 360ms ease, stroke-width 260ms ease; transform-origin:center center; }
    .control-row{ display:flex; gap:8px; align-items:center; }
    .small{ padding:6px 8px; border-radius:8px; background:transparent; color:var(--text); border:1px solid rgba(255,255,255,0.03); cursor:pointer; }

    /* Popup upload preview tweaks */
    .marker-upload-preview{ margin-top:6px; display:flex; flex-direction:column; gap:8px; }
    .marker-upload-preview .thumb-row{ display:flex; gap:8px; flex-wrap:wrap; }
    /* larger thumbnails and allow pointer to open full image */
    .marker-upload-preview img{ width:160px; height:120px; object-fit:cover; border-radius:8px; display:block; border:1px solid rgba(255,255,255,0.06); cursor:pointer; }

    /* Improve file input and popup styles to match dark theme */
    .popup-input{ width:100%; padding:6px; margin-top:6px; border-radius:6px; background:var(--glass); border:1px solid rgba(255,255,255,0.04); color:var(--text); }
    .popup-label{ margin-top:8px; display:block; color:var(--text); font-weight:700; }

    /* LIGHTBOX for full-image preview */
    #lightbox{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(2,6,23,0.85); z-index:9999; }
    #lightbox.show{ display:flex; }
    #lightbox img{ max-width:92vw; max-height:92vh; border-radius:8px; box-shadow:0 12px 40px rgba(0,0,0,0.7); }
    #lightboxClose{ position:absolute; top:18px; right:18px; background:transparent; border:0; color:white; font-size:34px; line-height:1; cursor:pointer; padding:8px 12px; }

    /* COLLAGE STYLES (for popup image preview) */
    .collage{ display:grid; gap:8px; }
    .collage img{ width:100%; height:100%; object-fit:cover; border-radius:8px; cursor:pointer; display:block; }
    .collage.count-1{ grid-template-columns: 1fr; }
    .collage.count-2{ grid-template-columns: 1fr 1fr; }
    .collage.count-3{ grid-template-columns: 2fr 1fr; grid-auto-rows: 1fr; }
    .collage.count-3 img:first-child{ grid-row: 1 / span 2; }
    @media (max-width:420px){ .collage.count-3{ grid-template-columns: 1fr; } .collage.count-2{ grid-template-columns: 1fr; } }

  </style>
</head>
<body>
  <div class="app">
    <aside class="panel" role="complementary" aria-label="Controls">
      <div style="display:flex;gap:12px;align-items:center">
        <div class="logo">SK</div>
        <div style="min-width:0">
          <h1 style="margin:0;color:var(--text);font-size:16px">Sikkim GeoJSON</h1>
          <p class="subtitle">Dark, wide borders enabled — real OSM roads</p>
        </div>
      </div>

      <div style="margin-top:6px">
        <label style="font-size:13px;color:var(--text);display:block;margin-bottom:6px">Search place (Sikkim only)</label>
        <div style="display:flex;gap:8px;align-items:center"><input id="searchInput" type="search" placeholder="e.g. Gangtok" style="flex:1;padding:8px;border-radius:8px;background:transparent;color:inherit;border:1px solid rgba(255,255,255,0.03)"><button id="searchBtn" class="small">Search</button></div>
        <div id="searchResults" style="display:none;max-height:220px;overflow:auto;border-radius:10px;margin-top:8px"></div>
      </div>

      <div style="margin-top:10px;display:flex;flex-direction:column;gap:10px">
        <div style="display:flex;gap:8px;align-items:center">
          <label style="flex:1">Base map</label>
          <select id="basemapSelect" style="background:transparent;color:inherit;border-radius:8px;padding:6px;border:1px solid rgba(255,255,255,0.03)">
            <option value="osm">OpenStreetMap</option>
            <option value="sat">Satellite</option>
            <option value="gray">Grayscale</option>
          </select>
        </div>

        <div style="display:flex;gap:8px;align-items:center">
          <label style="flex:1">GeoJSON opacity</label>
          <input id="opacity" type="range" min="0" max="1" step="0.05" value="0.5" style="flex:1">
        </div>

        <div style="display:flex;flex-direction:column;gap:6px">
          <div class="control-row"><input id="colorToggle" type="checkbox" checked /><label for="colorToggle">Show district colors</label></div>
          <div class="control-row"><input id="borderToggle" type="checkbox" checked /><label for="borderToggle">Show borders (dark & wide)</label></div>
          <div class="control-row"><input id="roadsToggle" type="checkbox" /><label for="roadsToggle">Show roads (OSM)</label></div>

          <!-- Roads filter UI (new) -->
          <div style="display:flex;gap:8px;align-items:center">
            <label style="flex:1">Road filter</label>
            <select id="roadsFilterSelect" style="background:transparent;color:inherit;border-radius:8px;padding:6px;border:1px solid rgba(255,255,255,0.03)">
              <option value="major">Major roads (motorway/trunk/primary/...)</option>
              <option value="national">National Highways only (ref starts with "NH")</option>
            </select>
          </div>

          <div class="control-row"><input id="locationsToggle" type="checkbox" /><label for="locationsToggle">Show important locations</label></div>
          <div class="control-row"><input id="citiesToggle" type="checkbox" /><label for="citiesToggle">Show cities</label></div>
        </div>

        <div style="display:flex;gap:8px"><button id="zoomToAll" class="small">Zoom to Sikkim</button><button id="streetView" class="small">Street View</button></div>

        <!-- NEW: Marking controls -->
        <div style="margin-top:6px;display:flex;gap:8px;align-items:center">
          <button id="markToggle" class="small" aria-pressed="false">Mark location</button>
          <button id="clearMarkers" class="small">Clear markers</button>
        </div>

        <div style="margin-top:6px"><strong style="color:var(--text)">Districts</strong><div id="legendItems" style="margin-top:8px"></div></div>
      </div>
    </aside>

    <main style="position:relative">
      <div id="map" role="application" aria-label="Map"></div>
      <div class="info" id="infoCard"><div style="display:flex;gap:10px;align-items:center"><img src="https://res.cloudinary.com/dbrvducfo/image/upload/v1757004023/buddha-removebg-preview_razlnq.png" style="width:64px;height:64px;object-fit:contain;border-radius:8px"><div><h3 style="margin:0;color:var(--sikkim-yellow)">Hover over a district</h3><p id="infoText" style="margin:0;color:var(--muted)">District name, code and other properties appear here.</p></div></div></div>
    </main>
  </div>

  <!-- LIGHTBOX DOM -->
  <div id="lightbox" aria-hidden="true">
    <button id="lightboxClose" aria-label="Close preview">×</button>
    <img id="lightboxImg" src="" alt="Full preview">
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    /***********************
     *  PLACEHOLDER GEOJSON
     *  Replace these with your real data (or fetch externally)
     ***********************/
    const geojson = {{ geojson|safe }};; // replace with your district GeoJSON (FeatureCollection) 

    // small placeholder for locations (so toggle won't error if you don't provide data)
    const locationsGeoJSON = {
      "type": "FeatureCollection",
      "features": [
        /* add features like airports, govt buildings if you have them */
      ]
    };

    // Sample cities (points) — replace with your own data if available
    const citiesGeoJSON = {{ citiesgeojson|safe }}

    /***********************
     *  Map & base layers
     ***********************/
    const map = L.map('map', { zoomControl:false });
    L.control.scale({position:'bottomleft'}).addTo(map);
    L.control.zoom({position:'bottomright'}).addTo(map);

    // ----- tile layers -----
    const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '© OpenStreetMap contributors' });
    const satellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles © Esri' });
    const gray = L.tileLayer('https://tiles.wmflabs.org/bw-mapnik/{z}/{x}/{y}.png', { maxZoom: 18, attribution: '© OpenStreetMap contributors' });

    osm.setZIndex(0); satellite.setZIndex(0); gray.setZIndex(0);
    osm.addTo(map);

    const osmOverlay = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '© OpenStreetMap contributors', pane: 'overlayPane' });
    osmOverlay.setZIndex(650);

    /***********************
     *  Colors & style helpers
     ***********************/
    const districtColors = {
      'East District':   '#fff200',
      'North  District': '#07119e',
      'South District':  '#ff1b00',
      'West District':   '#2ea043'
    };
    function getColorByName(name){ return districtColors[name] || '#94a3b8'; }

    const BASE_BORDER_COLOR = getComputedStyle(document.documentElement).getPropertyValue('--border-dark') || '#000814';
    const BASE_BORDER_WEIGHT = 4; // default wide border

    function baseStyle(feature){
      const name = feature.properties && (feature.properties.Dist_Name || feature.properties.DIST_NAME || feature.properties.Dist || feature.properties.name);
      return { color: BASE_BORDER_COLOR, weight: BASE_BORDER_WEIGHT, fillColor:getColorByName(name), fillOpacity:0.5, dashArray:'', lineJoin:'round' };
    }

    const svgRenderer = L.svg();

    /***********************
     *  Info card
     ***********************/
    const infoCard = document.getElementById('infoCard');
    const thumbUrl = 'https://res.cloudinary.com/dbrvducfo/image/upload/v1757004023/buddha-removebg-preview_razlnq.png';
    function showInfo(props){
      if(!props){
        infoCard.innerHTML = `<div style="display:flex;gap:10px;align-items:center"><img src="${thumbUrl}" style="width:64px;height:64px;object-fit:contain;border-radius:8px"><div><h3 style="margin:0;color:var(--sikkim-yellow)">Hover over a district</h3><p id="infoText" style="margin:0;color:var(--muted)">District name, code and other properties appear here.</p></div></div>`;
        return;
      }
      infoCard.innerHTML = `<div style="display:flex;gap:10px;align-items:center"><img src="${thumbUrl}" style="width:64px;height:64px;object-fit:contain;border-radius:8px"><div><h3 style="margin:0;color:var(--sikkim-yellow)">${props.Dist_Name||props.name||props.title||'Feature'}</h3><p style="margin:0;color:var(--muted)">${props.State_Name||props.type||''}</p></div></div>`;
    }

    /***********************
     *  Layer creation & toggle logic
     ***********************/
    const opacityEl = document.getElementById('opacity');
    const colorToggle = document.getElementById('colorToggle');
    const borderToggle = document.getElementById('borderToggle');
    const roadsToggle = document.getElementById('roadsToggle');
    const locationsToggle = document.getElementById('locationsToggle');
    const citiesToggle = document.getElementById('citiesToggle');

    const geoLayer = L.geoJSON(geojson, {
      renderer: svgRenderer,
      style: baseStyle,
      onEachFeature: function(feature, layer){
        const p = feature.properties || {};
        const tooltipHtml = `<div style="display:flex;align-items:center"><div style="line-height:1.05;"><div style="font-weight:700;color:var(--text);">${p.Dist_Name || 'District'}</div><div style="font-size:11px;color:var(--muted)">${p.State_Name || ''}</div></div></div>`;
        layer.bindTooltip(tooltipHtml, { className: 'nice-tooltip', direction: 'top', offset: [0, -8], opacity: 0.95 });

        layer.on({
          mouseover(e){
            const l = e.target;
            const showColors = colorToggle.checked;
            const showBorders = borderToggle.checked;
            const name = l.feature && (l.feature.properties && (l.feature.properties.Dist_Name || l.feature.properties.name));
            const color = getColorByName(name);
            const fillOpacity = showColors ? 0.7 : 0;
            const strokeOpacity = showBorders ? 0.95 : 0;
            const strokeColor = showBorders ? BASE_BORDER_COLOR : 'transparent';
            const weight = showBorders ? 6 : 0;
            try{
              l.setStyle({ weight, fillColor: color, fillOpacity, color: strokeColor, opacity: strokeOpacity });
              const el = l.getElement && l.getElement();
              if(el){
                el.setAttribute('fill', showColors ? color : 'transparent');
                el.setAttribute('fill-opacity', String(fillOpacity));
                el.setAttribute('stroke-opacity', String(strokeOpacity));
                el.setAttribute('stroke', strokeColor);
                el.setAttribute('stroke-width', weight + 'px');
                el.setAttribute('tabindex','-1'); el.setAttribute('focusable','false');
                el.style.outline='none'; el.style.boxShadow='none';
              }
            }catch(e){}
            if(!L.Browser.ie && !L.Browser.opera && !L.Browser.edge){ l.bringToFront(); }
            showInfo(feature.properties);
          },
          mouseout(e){
            updateLayerDisplay(e.target);
            showInfo();
          },
          click(e){
            map.flyToBounds(e.target.getBounds(), {padding:[30,30], duration:0.9});
            if(e.target.openPopup) e.target.openPopup();
          }
        });

        setTimeout(()=> updateLayerDisplay(layer), 0);
      }
    }).addTo(map);

    // roads layer will be created from Overpass (OSM) — see code further down
    let roadsLayer = null;

    let locationsLayer = null;
    function createLocationsLayer(){
      if(locationsLayer) return locationsLayer;
      locationsLayer = L.geoJSON(locationsGeoJSON, {
        pointToLayer(feature, latlng){
          const t = (feature.properties && feature.properties.type) || 'place';
          return L.circleMarker(latlng, { radius:8, fill:true, fillOpacity:1, fillColor: (t==='airport'? '#ffcc00' : '#fff200'), color:'#111827', weight:1, opacity:0.95 });
        },
        onEachFeature(feature, layer){ const name = (feature.properties && feature.properties.name) || 'Location'; layer.bindPopup(`<strong>${name}</strong>`); }
      });
      return locationsLayer;
    }

    // === PANES: ensure roads < cities ===
    // roadsPane below tooltip (650) and popup (700), above markers (600)
    if(!map.getPane('roadsPane')){
      map.createPane('roadsPane');
      map.getPane('roadsPane').style.zIndex = 620; // CHANGED: was 650, keep below cities/tooltip
      map.getPane('roadsPane').style.pointerEvents = 'auto';
    }
    // NEW: dedicated cities pane above roads
    if(!map.getPane('citiesPane')){
      map.createPane('citiesPane');
      map.getPane('citiesPane').style.zIndex = 680; // above roads & tooltips; below popups(700)
      map.getPane('citiesPane').style.pointerEvents = 'auto';
    }

    let citiesLayer = null;
    function createCitiesLayer(){
      if(citiesLayer) return citiesLayer;
      citiesLayer = L.geoJSON(citiesGeoJSON, {
        pane: 'citiesPane', // NEW: force into high z-index pane
        pointToLayer(feature, latlng){
          const name = (feature.properties && feature.properties.name) || '';
          const iconHtml = `<div style="display:flex;flex-direction:column;align-items:center;font-size:12px;line-height:1;pointer-events:auto">
                              <div style="background:rgba(7,17,158,0.95);color:white;padding:4px 6px;border-radius:12px;font-weight:700">${name}</div>
                              <div style="width:10px;height:10px;border-radius:50%;background:rgba(245,158,11,0.95);margin-top:4px"></div>
                            </div>`;
          const icon = L.divIcon({ html: iconHtml, className: '', iconSize: [70, 36], iconAnchor: [35, 36] });
          // Optional: extra bump just in case
          return L.marker(latlng, { icon, zIndexOffset: 1000 }); // NEW
        },
        onEachFeature(feature, layer){
          const name = (feature.properties && feature.properties.name) || '';
          const pop = (feature.properties && feature.properties.pop) ? `<br>Pop: ${feature.properties.pop}` : '';
          layer.bindPopup(`<strong>${name}</strong>${pop}`);
        }
      });
      return citiesLayer;
    }

    /***********************
     *  Display & toggles helpers
     ***********************/
    function updateLayerDisplay(layer){
      if(!layer || !layer.feature) return;
      const showColor = colorToggle.checked;
      const showBorder = borderToggle.checked;
      const desiredFillOpacity = showColor ? parseFloat(opacityEl.value || 0.5) : 0;
      const desiredStrokeOpacity = showBorder ? 0.95 : 0;
      const name = layer.feature && (layer.feature.properties && (layer.feature.properties.Dist_Name || layer.feature.properties.DIST_NAME || layer.feature.properties.name)) || null;
      const fillColor = showColor ? getColorByName(name) : 'transparent';
      const strokeColor = showBorder ? BASE_BORDER_COLOR : 'transparent';
      const weight = showBorder ? BASE_BORDER_WEIGHT : 0;

      if(layer.setStyle) layer.setStyle({ fillColor, fillOpacity: desiredFillOpacity, color: strokeColor, opacity: desiredStrokeOpacity, weight });
      const el = layer.getElement && layer.getElement();
      if(el){
        try{ el.setAttribute('fill', fillColor); }catch(e){}
        try{ el.setAttribute('fill-opacity', String(desiredFillOpacity)); }catch(e){}
        try{ el.setAttribute('stroke-opacity', String(desiredStrokeOpacity)); }catch(e){}
        try{ el.setAttribute('stroke-width', weight + 'px'); }catch(e){}
        if(!showBorder) try{ el.setAttribute('stroke', 'transparent'); }catch(e){}
        else try{ el.setAttribute('stroke', BASE_BORDER_COLOR); }catch(e){}
        try{ el.setAttribute('tabindex','-1'); el.setAttribute('focusable','false'); el.style.outline='none'; el.style.boxShadow='none'; }catch(e){}
      }
    }

    function updateAllLayersDisplay(){
      geoLayer.eachLayer(l => updateLayerDisplay(l));
    }

    colorToggle.addEventListener('change', ()=>{ document.getElementById('legendItems').style.display = colorToggle.checked ? 'block' : 'none'; updateAllLayersDisplay(); if(map.hasLayer(geoLayer)) geoLayer.bringToFront(); });
    borderToggle.addEventListener('change', ()=>{ updateAllLayersDisplay(); if(map.hasLayer(geoLayer)) geoLayer.bringToFront(); });
    opacityEl.addEventListener('input', ()=> geoLayer.eachLayer(l=> { l.options = l.options || {}; l.options.fillOpacity = parseFloat(opacityEl.value); updateLayerDisplay(l); }));

    // roadsToggle listener will be attached later after Overpass code
    locationsToggle.addEventListener('change', ()=>{
      if(locationsToggle.checked) { createLocationsLayer().addTo(map); }
      else if(locationsLayer) map.removeLayer(locationsLayer);
      if(citiesLayer && map.hasLayer(citiesLayer)) citiesLayer.bringToFront(); // NEW: keep cities on top
    });

    citiesToggle.addEventListener('change', ()=>{
      if(citiesToggle.checked) { createCitiesLayer().addTo(map); citiesLayer.bringToFront(); } // NEW: bringToFront
      else if(citiesLayer) map.removeLayer(citiesLayer);
    });

    /***********************
     *  Bounds, legend, search, misc
     ***********************/
    const bounds = geoLayer.getBounds();
    if(bounds.isValid()){
      map.fitBounds(bounds, {padding:[20,20]});
      map.setMaxBounds(bounds.pad(0.15));
      const minZoom = map.getBoundsZoom(bounds);
      map.setMinZoom(minZoom);
    } else {
      map.setView([27.5,88.5], 8);
    }

    const legendEl = document.getElementById('legendItems');
    Object.keys(districtColors).forEach(k=>{
      const div = document.createElement('div'); div.className='legend-item'; div.innerHTML = `<div class="swatch" style="background:${districtColors[k]}"></div><div style="font-size:13px;color:var(--text)">${k}</div>`; legendEl.appendChild(div);
    });

    const basemapSelect = document.getElementById('basemapSelect');
    basemapSelect.addEventListener('change', ()=>{
      const val = basemapSelect.value;
      [osm, satellite, gray].forEach(layer => { if(map.hasLayer(layer)) map.removeLayer(layer); });
      if(val === 'osm') osm.addTo(map);
      else if(val === 'sat') satellite.addTo(map);
      else gray.addTo(map);

      if(typeof roadsLayer !== 'undefined' && roadsLayer && map.hasLayer(roadsLayer)) roadsLayer.bringToFront();
      if(typeof locationsLayer !== 'undefined' && locationsLayer && map.hasLayer(locationsLayer)) locationsLayer.bringToFront();
      if(typeof citiesLayer !== 'undefined' && citiesLayer && map.hasLayer(citiesLayer)) citiesLayer.bringToFront(); // NEW
      if(map.hasLayer(geoLayer)) geoLayer.bringToFront();

      updateOverlayVisibility();
    });

    function updateOverlayVisibility(){ 
      if(map.hasLayer(osmOverlay) && basemapSelect.value !== 'sat'){ map.removeLayer(osmOverlay); }
    }

    document.getElementById('zoomToAll').addEventListener('click', ()=>{ if(bounds.isValid()) map.flyToBounds(bounds, {padding:[30,30], duration: 1.2}); });
    document.getElementById('streetView').addEventListener('click', ()=>{ const c = bounds.getCenter(); const url = `https://www.google.com/maps/@?api=1&map_action=pano&viewpoint=${c.lat},${c.lng}`; window.open(url,'_blank'); });

    /***********************
     *  SIKKIM-ONLY GEOCODING (Nominatim)
     ***********************/
    const searchBtn = document.getElementById('searchBtn');
    const searchInput = document.getElementById('searchInput');
    const searchResults = document.getElementById('searchResults');
    const searchLayer = L.layerGroup().addTo(map);

    // Sikkim approximate bounding box (minLon, minLat, maxLon, maxLat)
    const SIKKIM_BBOX = {
      minLon: 87.8,
      minLat: 26.8,
      maxLon: 88.95,
      maxLat: 28.2
    };

    async function geocode(q){
      if(!q||!q.trim()) return [];
      const vb = `${SIKKIM_BBOX.minLon},${SIKKIM_BBOX.minLat},${SIKKIM_BBOX.maxLon},${SIKKIM_BBOX.maxLat}`;
      const url = `https://nominatim.openstreetmap.org/search?format=json&addressdetails=1&limit=10&viewbox=${vb}&bounded=1&countrycodes=in&q=${encodeURIComponent(q)}`;
      try{
        const res = await fetch(url, { headers: { 'Accept': 'application/json', 'User-Agent': 'SikkimGeoJSON/1.0 (your-email@example.com)' }});
        if(!res.ok) return [];
        const data = await res.json();
        return data || [];
      }catch(e){
        console.warn('geocode error', e);
        return [];
      }
    }

    function clearResults(){ searchResults.innerHTML=''; searchResults.style.display='none'; }
    function showResults(list){
      searchResults.innerHTML='';

      const filtered = (list || []).filter(item=>{
        if(!item) return false;
        if(item.address && (item.address.state === 'Sikkim' || (item.address.state && item.address.state.toLowerCase().includes('sikkim')))) return true;
        if(item.display_name && item.display_name.toLowerCase().includes('sikkim')) return true;
        return false;
      });

      if(!filtered.length){
        searchResults.innerHTML = `<div style="padding:8px;color:var(--muted)">No results found inside <strong>Sikkim</strong>. Try a different query.</div>`;
        searchResults.style.display='block';
        return;
      }

      filtered.forEach(item=>{
        const div = document.createElement('div');
        div.style.padding='8px';
        div.style.borderBottom='1px solid rgba(255,255,255,0.03)';
        const shortName = (item.display_name || '').replace(/,?\s*India.*$/i, '');
        div.innerHTML = `<strong style="color:var(--text)">${shortName}</strong><br><small style="color:var(--muted)">${item.type} • ${item.class}</small>`;
        div.addEventListener('click', ()=> selectResult(item));
        searchResults.appendChild(div);
      });
      searchResults.style.display='block';
    }

    async function selectResult(item){
      clearResults();
      searchInput.value = item.display_name || '';
      searchLayer.clearLayers();

      if(!(item.address && (item.address.state === 'Sikkim' || (item.address.state && item.address.state.toLowerCase().includes('sikkim'))) || (item.display_name && item.display_name.toLowerCase().includes('sikkim')))){
        alert('That place does not appear to be inside Sikkim.');
        return;
      }

      const lat = parseFloat(item.lat), lon = parseFloat(item.lon);
      if(item.boundingbox && item.boundingbox.length===4){
        const b = item.boundingbox.map(v=>parseFloat(v));
        const south = Math.min(b[0], b[1]);
        const north = Math.max(b[0], b[1]);
        const west  = Math.min(b[2], b[3]);
        const east  = Math.max(b[2], b[3]);
        const bb = L.latLngBounds([south, west],[north, east]);
        if(Math.abs(north - south) < 0.0005 && Math.abs(east - west) < 0.0005){
          map.setView([lat, lon], 15);
        } else {
          map.flyToBounds(bb, {padding:[30,30], duration: 0.9});
        }
      } else {
        map.flyTo([lat, lon], 15, {duration:0.9});
      }
      const mk = L.marker([lat, lon]).addTo(searchLayer).bindPopup(`<strong>${item.display_name}</strong>`).openPopup();
    }

    searchBtn.addEventListener('click', async ()=>{
      const q = searchInput.value;
      if(!q.trim()) return;
      searchResults.innerHTML = '<div style="padding:8px">Searching…</div>';
      searchResults.style.display='block';
      const results = await geocode(q);
      showResults(results);
    });

    searchInput.addEventListener('keydown', (e)=>{ if(e.key === 'Enter') { e.preventDefault(); searchBtn.click(); }});

    /***********************
     *  REAL ROADS: Overpass -> GeoJSON (MAJOR / NATIONAL FILTERS)
     ***********************/
    let roadsLayer1 = null;
    let roadsFetched = false;

    const roadsFilterSelect = document.getElementById('roadsFilterSelect');

    const highwayWeight = (hw) => {
      if(!hw) return 2;
      if(['motorway','trunk','primary'].includes(hw)) return 6;
      if(['secondary','tertiary'].includes(hw)) return 4;
      if(['residential','unclassified','service','living_street'].includes(hw)) return 2;
      return 3;
    };

    function roadStyleByFeature(feature){
      const hw = feature.properties && (feature.properties.highway || '').toString();
      let color = 'rgba(245,158,11,0.95)';
      if(/motorway/.test(hw)) color = 'rgba(220,53,69,0.95)';
      else if(/trunk/.test(hw)) color = 'rgba(255,140,0,0.95)';
      else if(/primary/.test(hw)) color = 'rgba(255,215,0,0.95)';
      else if(/secondary/.test(hw)) color = 'rgba(200,200,200,0.95)';
      const weight = highwayWeight(hw);
      return { color, weight, opacity: 0.95, lineCap: 'round' };
    }

    function overpassToGeoJSON(overpassJson){
      if(!overpassJson || !Array.isArray(overpassJson.elements)) return { type:'FeatureCollection', features:[] };
      const wayElements = overpassJson.elements.filter(el => el.type === 'way' && Array.isArray(el.geometry) && el.geometry.length);
      const features = wayElements.map(way => {
        const coords = way.geometry.map(g => [g.lon, g.lat]);
        return {
          type: 'Feature',
          geometry: { type: 'LineString', coordinates: coords },
          properties: Object.assign({}, way.tags || {}, { osmid: way.id })
        };
      });
      return { type:'FeatureCollection', features };
    }

    function createRoadsLayerFromGeoJSON(geojsonData){
      if(roadsLayer1){
        try{ map.removeLayer(roadsLayer1); }catch(e){}
        roadsLayer1 = null;
      }
      roadsLayer1 = L.geoJSON(geojsonData, {
        pane: 'roadsPane',
        style: roadStyleByFeature,
        onEachFeature(feature, layer){
          const name = feature.properties && (feature.properties.name || '');
          const hw = feature.properties && (feature.properties.highway || '');
          if(name || hw) layer.bindPopup(`<strong>${name || '(unnamed)'}</strong><br><small>${hw}</small>`);
        }
      });

      if(roadsToggle.checked && roadsLayer1 && !map.hasLayer(roadsLayer1)) roadsLayer1.addTo(map);
      if(roadsLayer1 && map.hasLayer(roadsLayer1)) roadsLayer1.bringToFront();
      if(citiesLayer && map.hasLayer(citiesLayer)) citiesLayer.bringToFront();
    }

    const OVERPASS_ENDPOINTS = [
      'https://overpass-api.de/api/interpreter',
      'https://overpass.kumi.systems/api/interpreter',
      'https://lz4.overpass-api.de/api/interpreter'
    ];

    async function tryPostOverpass(endpoint, body){
      const resp = await fetch(endpoint, { method:'POST', body, headers: { 'Content-Type': 'text/plain; charset=UTF-8', 'Accept': 'application/json' }});
      if(!resp.ok) throw new Error(`Overpass ${endpoint} returned ${resp.status}`);
      return await resp.json();
    }

    async function fetchOSMRoads(){
      const south = SIKKIM_BBOX.minLat, west = SIKKIM_BBOX.minLon, north = SIKKIM_BBOX.maxLat, east = SIKKIM_BBOX.maxLon;
      const bbox = `${south},${west},${north},${east}`;

      const mode = (roadsFilterSelect && roadsFilterSelect.value) ? roadsFilterSelect.value : 'major';

      let query = '';
      if(mode === 'national'){
        query = `
[out:json][timeout:60];
(
  way["highway"]["ref"~"^NH"](${bbox});
  way["highway"]["name"~"\\bNational Highway\\b", i](${bbox});
);
out geom;
`;
      } else {
        query = `
[out:json][timeout:60];
(
  way["highway"~"^(motorway|trunk|primary|secondary|tertiary|motorway_link|trunk_link|primary_link|secondary_link)$"](${bbox});
);
out geom;
`;
      }

      if(searchResults){
        searchResults.innerHTML = '<div style="padding:8px">Loading road network… (Overpass)</div>';
        searchResults.style.display = 'block';
      }

      let lastError = null;
      for(const ep of OVERPASS_ENDPOINTS){
        try{
          const data = await tryPostOverpass(ep, query);
          const geo = overpassToGeoJSON(data);
          if(!geo || !geo.features || geo.features.length === 0){
            lastError = new Error('No way geometries returned (empty feature list)');
            continue;
          }
          createRoadsLayerFromGeoJSON(geo);
          roadsFetched = true;
          if(searchResults) clearResults();
          return;
        }catch(err){
          console.warn(`Overpass fetch failed at ${ep}:`, err);
          lastError = err;
        }
      }

      console.error('All Overpass endpoints failed', lastError);
      if(searchResults){
        searchResults.innerHTML = `<div style="padding:8px;color:var(--muted)">Could not load roads: ${lastError && lastError.message ? lastError.message : 'unknown'}. Try again later.</div>`;
        searchResults.style.display = 'block';
      } else {
        alert('Could not load OSM roads. Check console for details.');
      }
    }

    async function ensureRoadsVisible(){
      if(roadsToggle.checked){
        if(roadsFetched && roadsLayer1 && roadsFilterSelect && roadsFilterSelect._lastMode === roadsFilterSelect.value){
          if(!map.hasLayer(roadsLayer1)) roadsLayer1.addTo(map);
          roadsLayer1.bringToFront();
          if(citiesLayer && map.hasLayer(citiesLayer)) citiesLayer.bringToFront(); // NEW
          return;
        }
        await fetchOSMRoads();
        if(roadsLayer1 && !map.hasLayer(roadsLayer1)) roadsLayer1.addTo(map);
        if(roadsLayer1 && map.hasLayer(roadsLayer1)) roadsLayer1.bringToFront();
        if(citiesLayer && map.hasLayer(citiesLayer)) citiesLayer.bringToFront(); // NEW
        if(roadsFilterSelect) roadsFilterSelect._lastMode = roadsFilterSelect.value;
      } else {
        if(roadsLayer1 && map.hasLayer(roadsLayer1)) map.removeLayer(roadsLayer1);
      }
    }

    roadsToggle.addEventListener('change', ensureRoadsVisible);
    if(roadsFilterSelect) roadsFilterSelect.addEventListener('change', async ()=>{
      if(roadsToggle.checked){
        roadsFetched = false;
        await ensureRoadsVisible();
      }
    });

    /***********************
     *  MARK LOCATION: multiple-image upload (up to 3 images)
     *  — now with full-image preview (lightbox) and clickable thumbnails
     ***********************/
    const markToggle = document.getElementById('markToggle');
    const clearMarkersBtn = document.getElementById('clearMarkers');
    let markMode = false;
    const markersGroup = L.layerGroup().addTo(map);
    const markersList = [];

    function escapeHtml(unsafe) {
      if(!unsafe && unsafe !== 0) return '';
      return String(unsafe)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }

    // LIGHTBOX helpers (global so popup images can call window.openLightbox)
    const lightbox = document.getElementById('lightbox');
    const lightboxImg = document.getElementById('lightboxImg');
    const lightboxClose = document.getElementById('lightboxClose');
    function openLightbox(src){
      if(!src) return;
      lightboxImg.src = src;
      lightbox.classList.add('show');
      lightbox.setAttribute('aria-hidden', 'false');
    }
    function closeLightbox(){
      lightbox.classList.remove('show');
      lightbox.setAttribute('aria-hidden', 'true');
      // revoke large image src from memory if needed (only dataURLs here)
      try{ lightboxImg.src = ''; }catch(e){}
    }
    lightboxClose.addEventListener('click', closeLightbox);
    lightbox.addEventListener('click', (ev)=>{ if(ev.target === lightbox) closeLightbox(); });

    function onMapClickForMarking(e){
      const lat = e.latlng.lat;
      const lng = e.latlng.lng;

      const id = 'm' + Date.now() + Math.floor(Math.random()*999);

      // Build a popup that includes a title field and file input for up to 3 images
      const popupHtml = `
        <div id="${id}-popup" style="min-width:260px;font-size:13px;color:var(--text)">
                      <label class="popup-label" style="color:black"  >Title</label>
          <input id="${id}-title" style="color:black"  type="text" placeholder="Short title" class="popup-input">
        
          <label class="popup-label" style="color:black" >Photos (up to 3)</label>
          <input id="${id}-file" type="file" accept="image/*" multiple class="popup-input">

          <div id="${id}-preview" class="marker-upload-preview" style="display:none">
            <!-- thumbnails will be injected here -->
            <div class="thumb-row" id="${id}-thumbs"></div>
          </div>

          <div style="margin-top:8px;display:flex;gap:8px;justify-content:flex-end">
            <button id="${id}-save" class="small" style="color: red;" >Save</button>
            <button id="${id}-cancel" class="small" style="color: red;" >Close</button>
          </div>
        </div>
      `;

      const marker = L.marker([lat, lng], { draggable:true }).addTo(markersGroup);
      marker.bindPopup(popupHtml).openPopup();

      // store marker + meta placeholder
      markersList.push({ marker, meta: { title: '', images: [], lat, lng } });

      console.log('Marker added (pending):', { lat, lng });

      marker.on('dragend', function(){
        const p = marker.getLatLng();
        const entry = markersList.find(it => it.marker === marker);
        if(entry) { entry.meta.lat = p.lat; entry.meta.lng = p.lng; }
        console.log('Marker moved:', { lat: p.lat, lng: p.lng, meta: entry ? entry.meta : null });
      });

      marker.on('popupopen', function onPopupOpen(){
        const fileEl = document.getElementById(`${id}-file`);
        const titleEl = document.getElementById(`${id}-title`);
        const previewWrap = document.getElementById(`${id}-preview`);
        const thumbsRow = document.getElementById(`${id}-thumbs`);
        const saveBtn = document.getElementById(`${id}-save`);
        const cancelBtn = document.getElementById(`${id}-cancel`);
        if(!fileEl || !titleEl || !saveBtn || !cancelBtn) return;

        // Config
        const MAX_FILES = 3;
        const MAX_BYTES = 2 * 1024 * 1024; // 2 MB per image
        const MAX_DIMENSION = 1200; // max width/height for resized image

        let imagesData = []; // array of dataURLs
        let objectUrls = []; // keep track to revoke
        let _readers = [];
        let _listeners = [];

        function setError(msg){
          let errEl = document.getElementById(`${id}-error`);
          if(!errEl){
            errEl = document.createElement('div');
            errEl.id = `${id}-error`;
            errEl.style.color = '#ffb4b4';
            errEl.style.fontSize = '12px';
            errEl.style.marginTop = '6px';
            previewWrap.parentNode.insertBefore(errEl, previewWrap.nextSibling);
          }
          errEl.textContent = msg || '';
        }
        function clearError(){ const errEl = document.getElementById(`${id}-error`); if(errEl) errEl.textContent=''; }

        function setLoading(yes){ if(yes){ saveBtn.textContent = 'Saving…'; saveBtn.disabled = true; } else { saveBtn.textContent = 'Save'; saveBtn.disabled = false; } }

        function resizeImageIfNeeded(img, mimeType, maxDim){
          return new Promise((resolve, reject) => {
            const w = img.width, h = img.height;
            let nw = w, nh = h;
            if(Math.max(w, h) > maxDim){
              if(w >= h){ nw = maxDim; nh = Math.round(h * (maxDim / w)); } else { nh = maxDim; nw = Math.round(w * (maxDim / h)); }
            }
            const canvas = document.createElement('canvas');
            canvas.width = nw; canvas.height = nh;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, nw, nh);
            resolve(canvas.toDataURL(mimeType || 'image/jpeg', 0.85));
          });
        }

        async function finalizeWithImage(imgSrc, mimeType){
          // returns dataUrl or throws
          const tmp = new Image();
          tmp.src = imgSrc;
          if(tmp.decode){
            await tmp.decode();
          } else {
            await new Promise((res, rej)=>{ tmp.onload = res; tmp.onerror = ()=> rej(new Error('decode failed')); });
          }
          const resized = await resizeImageIfNeeded(tmp, mimeType || 'image/jpeg', MAX_DIMENSION);
          return resized || imgSrc;
        }

        function clearThumbs(){ if(thumbsRow) thumbsRow.innerHTML = ''; }

        async function handleFiles(filesList){
          clearError();
          imagesData = [];
          objectUrls.forEach(u=>{ try{ URL.revokeObjectURL(u); }catch(e){} });
          objectUrls = [];
          clearThumbs();

          if(!filesList || filesList.length === 0){ previewWrap.style.display='none'; return; }

          const files = Array.from(filesList).slice(0, MAX_FILES);
          if(filesList.length > MAX_FILES) setError('Only the first 3 images will be used.');

          previewWrap.style.display = 'flex';

          // process each file; show thumb as soon as available
          await Promise.all(files.map(async (f, idx) => {
            if(!f.type || !f.type.startsWith('image/')){
              setError('One of the files is not an image. Skipping.');
              return;
            }
            const objectUrl = URL.createObjectURL(f);
            objectUrls.push(objectUrl);
            try{
              const dataURL = await finalizeWithImage(objectUrl, f.type);
              imagesData.push(dataURL);

              // ensure the popup still exists before manipulating DOM
              const realThumbsRow = document.getElementById(`${id}-thumbs`);
              if(realThumbsRow){
                const img = document.createElement('img');
                img.src = dataURL;
                img.alt = `preview-${idx+1}`;
                img.addEventListener('click', ()=> openLightbox(dataURL)); // open full image
                realThumbsRow.appendChild(img);
              }
            }catch(err){
              console.warn('Image processing failed for a file, trying FileReader fallback', err);
              // fallback: read as data URL
              try{
                const resultDataUrl = await new Promise((resolve, reject) => {
                  const fr = new FileReader();
                  fr.onerror = () => reject(new Error('FileReader failed'));
                  fr.onload = e => resolve(e.target.result);
                  fr.readAsDataURL(f);
                });
                const tmp = new Image(); tmp.src = resultDataUrl;
                if(tmp.decode) await tmp.decode(); else await new Promise((res, rej)=>{ tmp.onload = res; tmp.onerror = rej; });
                const resized = await resizeImageIfNeeded(tmp, f.type || 'image/jpeg', MAX_DIMENSION);
                imagesData.push(resized || resultDataUrl);
                const realThumbsRow = document.getElementById(`${id}-thumbs`);
                if(realThumbsRow){ const img = document.createElement('img'); img.src = resized || resultDataUrl; img.addEventListener('click', ()=> openLightbox(resized || resultDataUrl)); realThumbsRow.appendChild(img); }
              }catch(fbErr){
                console.error('Fallback also failed for file', fbErr);
                setError('Some images could not be processed. Try smaller files or different formats.');
              }
            }
          }));

          // done processing
          setLoading(false);
        }

        function handleFileChange(evt){
          setLoading(true);
          handleFiles(evt.target.files).finally(()=> setLoading(false));
        }

        function handleSaveClick(){
          setError('');
          setLoading(true);
          setTimeout(()=>{
            const title = (titleEl && titleEl.value) ? titleEl.value.trim() : '';
            const entry = markersList.find(it => it.marker === marker);
            if(entry){
              entry.meta.title = title;
              entry.meta.images = imagesData.slice();
              entry.meta.lat = marker.getLatLng().lat;
              entry.meta.lng = marker.getLatLng().lng;
            }
            const safeTitle = escapeHtml(title) || '<em>No title</em>';
            let finalHtml = `<div style="font-size:13px;color:var(--text);min-width:220px"><strong style="color:black">${safeTitle}</strong><br><small>${marker.getLatLng().lat.toFixed(6)}, ${marker.getLatLng().lng.toFixed(6)}</small>`;
            if(entry && entry.meta.images && entry.meta.images.length){
              // COLLAGE: create a responsive grid collage depending on number of images (1 / 2 / 3)
              finalHtml += `<div style="margin-top:8px"><div class="collage count-${entry.meta.images.length}">`;
              entry.meta.images.forEach((src, idx) => {
                finalHtml += `<img src="${src}" alt="img${idx+1}" onclick="window.openLightbox(${JSON.stringify(src)})">`;
              });
              finalHtml += `</div></div>`;
            }
            finalHtml += `</div>`;
            marker.setPopupContent(finalHtml);
            marker._meta = entry ? entry.meta : { title, images: imagesData, lat: marker.getLatLng().lat, lng: marker.getLatLng().lng };
            setLoading(false);
            console.log('Marker saved:', marker._meta);
            marker.closePopup();
          }, 150);
        }

        function handleCancel(){ marker.closePopup(); }

        // add listeners and keep references for cleanup
        fileEl.addEventListener('change', handleFileChange); _listeners.push(['change', fileEl, handleFileChange]);
        saveBtn.addEventListener('click', handleSaveClick); _listeners.push(['click', saveBtn, handleSaveClick]);
        cancelBtn.addEventListener('click', handleCancel); _listeners.push(['click', cancelBtn, handleCancel]);

        // cleanup when popup closes
        marker.once('popupclose', function cleanupPopup(){
          // revoke object URLs
          objectUrls.forEach(u=>{ try{ URL.revokeObjectURL(u); }catch(e){} });
          objectUrls = [];
          // abort readers if any (none kept now) -- for safety
          try{ _readers.forEach(r=>{ if(r && r.readyState === 1) r.abort(); }); }catch(e){}
          // remove listeners
          _listeners.forEach(([ev, el, fn]) => { try{ el.removeEventListener(ev, fn); }catch(e){} });
          _listeners.length = 0;
          // hide preview / clear data
          if(previewWrap){ previewWrap.style.display = 'none'; }
          imagesData = [];
          clearThumbs();
          clearError();
          setLoading(false);
        });

      });

      if(citiesLayer && map.hasLayer(citiesLayer)) citiesLayer.bringToFront();
    }

    function enableMarkMode(){
      if(markMode) return;
      markMode = true;
      map.getContainer().style.cursor = 'crosshair';
      map.on('click', onMapClickForMarking);
      markToggle.setAttribute('aria-pressed','true');
      markToggle.classList.add('active');
    }

    function disableMarkMode(){
      if(!markMode) return;
      markMode = false;
      map.getContainer().style.cursor = '';
      map.off('click', onMapClickForMarking);
      markToggle.setAttribute('aria-pressed','false');
      markToggle.classList.remove('active');
    }

    markToggle.addEventListener('click', ()=>{ if(markMode) disableMarkMode(); else enableMarkMode(); });

    clearMarkersBtn.addEventListener('click', ()=>{ markersGroup.clearLayers(); markersList.length = 0; console.log('All markers cleared'); });

    document.addEventListener('keydown', (ev)=>{ if(ev.key === 'Escape' && markMode) disableMarkMode(); });

    /***********************
     *  Small animations & accessibility
     ***********************/
    function animateDistrictsStagger(){
      let i = 0; geoLayer.eachLayer(layer=>{
        try{
          const el = layer.getElement && layer.getElement();
          if(!el){ i++; return; }
          el.style.transition = 'transform 420ms cubic-bezier(.2,.9,.22,1), fill-opacity 420ms ease, stroke-width 260ms ease';
          el.style.transform = 'scale(.94)';
          const initialFill = (layer.options && layer.options.fillOpacity != null) ? layer.options.fillOpacity : (colorToggle.checked ? parseFloat(opacityEl.value || 0.5) : 0);
          el.setAttribute('fill-opacity', '0');
          setTimeout(()=>{
            const targetOpacity = initialFill;
            el.style.transform = 'scale(1)';
            el.setAttribute('fill-opacity', String(targetOpacity));
            if(layer.options && layer.options.weight) el.setAttribute('stroke-width', (layer.options.weight + 'px'));
            try{ el.setAttribute('tabindex','-1'); el.setAttribute('focusable','false'); el.style.outline='none'; el.style.boxShadow='none'; }catch(e){}
          }, 140 + (i*90));
        }catch(e){}
        i++;
      });
    }
    setTimeout(animateDistrictsStagger, 360);

    updateOverlayVisibility();
    document.getElementById('map').setAttribute('tabindex','0');

    // expose lightbox helper to popup inline handlers
    window.openLightbox = openLightbox;
    window.closeLightbox = closeLightbox;
  </script>
</body>
</html>
